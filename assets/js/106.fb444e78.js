(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{453:function(t,e,a){"use strict";a.r(e);var s=a(42),_=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),a("p",[t._v("数组是一种线性数据结构，使用一组连续的内存空间存放相同类型的数据。")]),t._v(" "),a("p",[t._v("数组的优势在于：可以实现随机访问")]),t._v(" "),a("p",[t._v("数组可以根据index计算出要访问的地址，实现随机访问，计算公式为：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("a[i]_address = base_address + i * data_type_size\n")])])]),a("p",[t._v("数组的劣势在于：为保证数据的连续性，插入和删除需要移位，比较低效，但某些场景可以优化操作：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("如果数据本身无序，插入时可以将原数据移动到数组尾部，然后插入新数据。")])]),t._v(" "),a("li",[a("p",[t._v("对于删除，可以采用标记删除，等到数组空间不够了再进行真正的删除。")]),t._v(" "),a("blockquote",[a("p",[t._v("JVM 标记清除垃圾回收算法的核心思想")])])])]),t._v(" "),a("p",[t._v("容器是对数组的封装，有两个优势：封装了数组操作细节，动态扩容，劣势在于无法存储基本类型，需要存储包装类型，有一定性能开销，不适合底层开发。")]),t._v(" "),a("blockquote",[a("p",[t._v("ArrayList自动扩容1.5倍")])])])}),[],!1,null,null,null);e.default=_.exports}}]);