(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{424:function(t,a,s){"use strict";s.r(a);var e=s(42),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"协程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协程"}},[t._v("#")]),t._v(" 协程")]),t._v(" "),s("h2",{attrs:{id:"什么是协程？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是协程？"}},[t._v("#")]),t._v(" 什么是协程？")]),t._v(" "),s("p",[t._v("协程是实现并发编程的一种方式。")]),t._v(" "),s("p",[t._v("诚然，多线程有诸多优点且应用广泛，但也存在一定的局限性：比如，多线程运行过程容易被打断，因此有可能出现 race condition 的情况；再如，线程切换本身存在一定的损耗，线程数不能无限增加，因此，如果你的 I/O 操作非常 heavy，多线程很有可能满足不了高效率、高质量的需求。")]),t._v(" "),s("h2",{attrs:{id:"async-await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[t._v("#")]),t._v(" async / await")]),t._v(" "),s("h2",{attrs:{id:"任务tasks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#任务tasks"}},[t._v("#")]),t._v(" 任务Tasks")]),t._v(" "),s("h2",{attrs:{id:"asyncio"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#asyncio"}},[t._v("#")]),t._v(" Asyncio")]),t._v(" "),s("p",[t._v("事实上，Asyncio 和其他 Python 程序一样，是单线程的，它只有一个主线程，但是可以进行多个不同的任务（task），这里的任务，就是特殊的 future 对象。这些不同的任务，被一个叫做 event loop 的对象所控制。你可以把这里的任务，类比成多线程版本里的多个线程。")]),t._v(" "),s("p",[t._v("值得一提的是，对于 Asyncio 来说，它的任务在运行时不会被外部的一些因素打断，因此 Asyncio 内的操作不会出现 race condition 的情况，这样你就不需要担心线程安全的问题了。")]),t._v(" "),s("h2",{attrs:{id:"来自fluent-python的部分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#来自fluent-python的部分"}},[t._v("#")]),t._v(" 来自fluent_python的部分")]),t._v(" "),s("h3",{attrs:{id:"协程的四种状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协程的四种状态"}},[t._v("#")]),t._v(" 协程的四种状态")]),t._v(" "),s("p",[t._v("'GEN_CREATED', 'GEN_RUNNING', 'GEN_SYSPENDED', 'GEN_CLOSED'分别：")]),t._v(" "),s("p",[t._v("创建等待执行，正在执行，在yield表达式处暂停，执行结束")]),t._v(" "),s("blockquote",[s("p",[t._v("当前状态可以使用inspect.getgeneratorstate(...)函数确定")])])])}),[],!1,null,null,null);a.default=r.exports}}]);