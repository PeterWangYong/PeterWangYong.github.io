(window.webpackJsonp=window.webpackJsonp||[]).push([[190],{536:function(t,e,s){"use strict";s.r(e);var a=s(42),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),s("blockquote",[s("p",[t._v("https://www.imooc.com/article/27083?block_id=tuijian_wz")]),t._v(" "),s("p",[t._v("https://zhuanlan.zhihu.com/p/34182184")]),t._v(" "),s("p",[t._v("https://zhuanlan.zhihu.com/p/54882306")]),t._v(" "),s("p",[t._v("https://zhuanlan.zhihu.com/p/33058983")])]),t._v(" "),s("p",[t._v("setimmediate 将任务注册到下一个check阶段，而不是当前的check阶段")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" promise "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Promise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" promise\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\npromise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("catch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 会导致死循环")]),t._v("\n")])])]),s("p",[t._v("9 5 8 1 4 7 3 6 2")]),t._v(" "),s("p",[t._v("执行一个宏任务执行一对微任务，而不是执行完一个阶段再执行微任务？")]),t._v(" "),s("h2",{attrs:{id:"node事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node事件循环"}},[t._v("#")]),t._v(" Node事件循环")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/PeterWangYong/blog-image/raw/master/images/5adae2480001f9c120241598.jpg",alt:"nodejs event loop workflow"}})]),t._v(" "),s("h3",{attrs:{id:"执行流程概览"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行流程概览"}},[t._v("#")]),t._v(" 执行流程概览")]),t._v(" "),s("ol",[s("li",[t._v("执行脚本，初始化事件循环")]),t._v(" "),s("li",[t._v("开始执行事件循环：\n"),s("ul",[s("li",[t._v("Timers: setTimeout, setInterval （比较当前时间和注册时间，执行所有过期的任务）")]),t._v(" "),s("li",[t._v("Pending IO: 其他的IO回调")]),t._v(" "),s("li",[t._v("Idle,prepare: 忽略")]),t._v(" "),s("li",[t._v("Poll：文件IO、服务器IO等")]),t._v(" "),s("li",[t._v("Check：setImmediate （执行所有当前Tick下的任务）")]),t._v(" "),s("li",[t._v("Close: on('close', fn)")])])]),t._v(" "),s("li",[t._v("下一个事件循环")])]),t._v(" "),s("h3",{attrs:{id:"宏任务的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宏任务的分类"}},[t._v("#")]),t._v(" 宏任务的分类")]),t._v(" "),s("p",[t._v("setTimeout, setInterval")]),t._v(" "),s("p",[t._v("setImmediate")]),t._v(" "),s("p",[t._v("IO 回调")]),t._v(" "),s("h3",{attrs:{id:"微任务的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#微任务的分类"}},[t._v("#")]),t._v(" 微任务的分类")]),t._v(" "),s("p",[t._v("process.nextTick")]),t._v(" "),s("p",[t._v("Promise.then")]),t._v(" "),s("h3",{attrs:{id:"微任务的执行时机"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#微任务的执行时机"}},[t._v("#")]),t._v(" 微任务的执行时机")]),t._v(" "),s("ol",[s("li",[t._v("当一个宏任务执行完毕后立即检查微任务队列，并执行所有微任务（没有限制）")]),t._v(" "),s("li",[t._v("微任务的执行顺序：先执行process.nextTick任务，再执行promise任务")])]),t._v(" "),s("h3",{attrs:{id:"setimmediate特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setimmediate特性"}},[t._v("#")]),t._v(" setImmediate特性")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("setImmediate相比于setTimeout而言少了一个时间比较的过程，执行更快（性能快出50倍左右，可以说是出于性能考虑使用setImmediate替代setTimeout(fn, 0))。")])]),t._v(" "),s("li",[s("p",[t._v("setImmediate置于Poll阶段之后，对于IO回调可以尽快的执行。")])]),t._v(" "),s("li",[s("p",[t._v("setImmediate会将现有的队列任务一次性读取到临时队列执行，所以在setImmediate中递归setImmediate不会阻塞JS执行。(见源码中QUEUE_MOVE方法)")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("uv__run_check(loop);\n\n// 在每一轮循环中执行该函数，执行时机见uv_run\n  void uv__run_##name(uv_loop_t* loop) {                                      \\\n    uv_##name##_t* h;                                                         \\\n    QUEUE queue;                                                              \\\n    QUEUE* q;                                                                 \\\n\n    // 把该类型对应的队列中所有节点摘下来挂载到queue变量\n    QUEUE_MOVE(&loop->name##_handles, &queue);                                \\\n\n   // 遍历队列，执行每个节点里面的函数\n    while (!QUEUE_EMPTY(&queue)) {                                            \\\n\n      // 取下当前待处理的节点\n      q = QUEUE_HEAD(&queue);                                                 \\\n\n      // 取得该节点对应的整个结构体的基地址\n      h = QUEUE_DATA(q, uv_##name##_t, queue);                                \\\n\n      // 把该节点移出当前队列\n      QUEUE_REMOVE(q);                                                        \\\n\n     // 重新插入原来的队列\n      QUEUE_INSERT_TAIL(&loop->name##_handles, q);                            \\\n\n     // 执行回调函数\n      h->name##_cb(h);                                                        \\\n    }                                                                         \\\n  }\n")])])])]),t._v(" "),s("li",[s("p",[t._v("只要在check阶段之前加入队列的任务都会被执行。")])])]),t._v(" "),s("h3",{attrs:{id:"process-nexttick特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#process-nexttick特性"}},[t._v("#")]),t._v(" process.nextTick特性")]),t._v(" "),s("ol",[s("li",[t._v("nextTick拥有自己的"),s("code",[t._v("TickQueue")]),t._v("队列，且优先级高于"),s("code",[t._v("PromiseQueue")])]),t._v(" "),s("li",[t._v("process.nextTick会在当前宏任务执行完毕之后（调用栈清空，包括全局代码执行完毕）立即执行")]),t._v(" "),s("li",[t._v("nextTick属于微任务，执行没有上限，所以如果递归调用容易造成JS阻塞。")]),t._v(" "),s("li",[t._v("nextTick用于那些真正需要优先的操作，不能滥用。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);