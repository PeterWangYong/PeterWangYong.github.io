(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{458:function(t,a,s){"use strict";s.r(a);var e=s(42),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"正则表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[t._v("#")]),t._v(" 正则表达式")]),t._v(" "),s("blockquote",[s("p",[s("a",{attrs:{href:"https://regex101.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("正则测试站点"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"正则的定义和功能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正则的定义和功能"}},[t._v("#")]),t._v(" 正则的定义和功能")]),t._v(" "),s("h3",{attrs:{id:"定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),s("p",[t._v("正则，就是正则表达式，英文是 Regular Expression，简称 RE。顾名思义，正则其实就是一种描述文本内容组成规律的表示方式。")]),t._v(" "),s("h3",{attrs:{id:"三大功能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三大功能"}},[t._v("#")]),t._v(" 三大功能")]),t._v(" "),s("ol",[s("li",[t._v("校验数据的有效性")]),t._v(" "),s("li",[t._v("查找符合要求的文本")]),t._v(" "),s("li",[t._v("对文本进行切割和替换等操作")])]),t._v(" "),s("h2",{attrs:{id:"元字符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#元字符"}},[t._v("#")]),t._v(" 元字符")]),t._v(" "),s("p",[t._v("所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，元字符是构成正则表达式的基本元件。")]),t._v(" "),s("h3",{attrs:{id:"特殊单字符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特殊单字符"}},[t._v("#")]),t._v(" 特殊单字符")]),t._v(" "),s("p",[s("code",[t._v(".")]),t._v(" 任意字符（换行除外）")]),t._v(" "),s("p",[s("code",[t._v("\\d")]),t._v(" 任意数字 "),s("code",[t._v("\\D")]),t._v(" 任意非数字    "),s("a",{attrs:{href:"https://regex101.com/r/PnzZ4k/1",target:"_blank",rel:"noopener noreferrer"}},[t._v("测试案例"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("code",[t._v("\\w")]),t._v(" 任意字母数字下划线 "),s("code",[t._v("\\W")]),t._v(" 任意非字母数字下划线   "),s("a",{attrs:{href:"https://regex101.com/r/PnzZ4k/2",target:"_blank",rel:"noopener noreferrer"}},[t._v("测试案例"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("code",[t._v("\\s")]),t._v(" 任意空白符 "),s("code",[t._v("\\S")]),t._v(" 任意非空白符")]),t._v(" "),s("h3",{attrs:{id:"空白符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#空白符"}},[t._v("#")]),t._v(" 空白符")]),t._v(" "),s("p",[s("code",[t._v("\\r")]),t._v(" 回车符")]),t._v(" "),s("p",[s("code",[t._v("\\n")]),t._v(" 换行符")]),t._v(" "),s("p",[s("code",[t._v("\\f")]),t._v(" 换页符")]),t._v(" "),s("p",[s("code",[t._v("\\t")]),t._v(" 制表符")]),t._v(" "),s("p",[s("code",[t._v("\\v")]),t._v(" 垂直制表符")]),t._v(" "),s("p",[s("code",[t._v("\\s")]),t._v(" 任意空白符")]),t._v(" "),s("h3",{attrs:{id:"范围"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#范围"}},[t._v("#")]),t._v(" 范围")]),t._v(" "),s("p",[s("code",[t._v("|")]),t._v(" 或，如ab|bc代表ab或bc")]),t._v(" "),s("p",[s("code",[t._v("[...]")]),t._v(" 多选一，括号中任意单个元素")]),t._v(" "),s("p",[s("code",[t._v("[a-z]")]),t._v(" 匹配a到z之间任意单个元素")]),t._v(" "),s("p",[s("code",[t._v("[^...]")]),t._v(" 取反，不能是括号中的任意单个元素")]),t._v(" "),s("h3",{attrs:{id:"量词"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#量词"}},[t._v("#")]),t._v(" 量词")]),t._v(" "),s("p",[s("code",[t._v("*")]),t._v(" 0到多次")]),t._v(" "),s("p",[s("code",[t._v("+")]),t._v(" 1到多次")]),t._v(" "),s("p",[s("code",[t._v("?")]),t._v(" 0到1次")]),t._v(" "),s("p",[s("code",[t._v("{m}")]),t._v(" 出现m次")]),t._v(" "),s("p",[s("code",[t._v("{m,}")]),t._v(" 出现至少m次")]),t._v(" "),s("p",[s("code",[t._v("{m,n}")]),t._v(" m到n次")]),t._v(" "),s("h3",{attrs:{id:"断言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#断言"}},[t._v("#")]),t._v(" 断言")]),t._v(" "),s("p",[t._v("在有些情况下，我们对要匹配的文本的位置也有一定的要求。为了解决这个问题，正则中提供了一些结构，只用于匹配位置，而不是文本内容本身，这种结构就是断言。")]),t._v(" "),s("p",[t._v("常见的断言有三种：")]),t._v(" "),s("ul",[s("li",[t._v("单词边界")]),t._v(" "),s("li",[t._v("行的开始或结束")]),t._v(" "),s("li",[t._v("环视")])]),t._v(" "),s("h4",{attrs:{id:"单词边界（word-boundary）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单词边界（word-boundary）"}},[t._v("#")]),t._v(" 单词边界（Word Boundary）")]),t._v(" "),s("p",[t._v("比如："),s("code",[t._v("tom")]),t._v(" 匹配 "),s("code",[t._v("tom tomorrow")]),t._v("，默认会匹配到两个。如果我们只想匹配前一个tom怎么办呢？")]),t._v(" "),s("p",[t._v("单词的组成一般可以用元字符 \\w+ 来表示，\\w 包括了大小写字母、下划线和数字（即 [A-Za-z0-9_]）。那如果我们能找出单词的边界，也就是当出现了\\w 表示的范围以外的字符，比如引号、空格、标点、换行等这些符号，我们就可以在正则中使用\\b 来表示单词的边界。 \\b 中的 b 可以理解为是边界（Boundary）这个单词的首字母。")]),t._v(" "),s("p",[s("code",[t._v("\\btom")]),t._v("表示以tom开头，"),s("code",[t._v("tom\\b")]),t._v("表示以tom结尾，"),s("code",[t._v("\\btom\\b")]),t._v("表示单词tom。")]),t._v(" "),s("h4",{attrs:{id:"行的开始或结束"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行的开始或结束"}},[t._v("#")]),t._v(" 行的开始或结束")]),t._v(" "),s("p",[t._v("如果我们要求匹配的内容要出现在一行文本开头或结尾，就可以使用 ^ 和 $ 来进行位置界定。")]),t._v(" "),s("p",[t._v("在多行模式下，^ 和 $ 符号可以匹配每一行的开头或结尾。大部分实现默认不是多行匹配模式，但也有例外，比如 Ruby 中默认是多行模式。所以对于校验输入数据来说，一种更严谨的做法是，使用 \\A 和 \\z （Python 中使用 \\Z） 来匹配整个文本的开头或结尾。")]),t._v(" "),s("h4",{attrs:{id:"环视（-look-around）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#环视（-look-around）"}},[t._v("#")]),t._v(" 环视（ Look Around）")]),t._v(" "),s("p",[t._v("环视就是要求匹配部分的前面或后面要满足（或不满足）某种规则，有些地方也称环视为"),s("strong",[t._v("零宽断言")]),t._v("。")]),t._v(" "),s("ul",[s("li",[t._v("(?<=Y) 左边是Y，"),s("code",[t._v("(?<=\\d)th")]),t._v(" 要求左边是数字，比如9th")]),t._v(" "),s("li",[t._v("(?<!Y) 左边不是Y，"),s("code",[t._v("(?<!\\d)th")]),t._v(" 要求左边不是数字，比如health")]),t._v(" "),s("li",[t._v("(?=Y) 右边是Y，"),s("code",[t._v("six(?=\\d)")]),t._v(" 要求右边是数字，比如six6")]),t._v(" "),s("li",[t._v("(?!Y) 右边不是Y，"),s("code",[t._v("hi(?!\\d)")]),t._v("要求右边不是数字，比如high")])]),t._v(" "),s("blockquote",[s("p",[t._v("口诀：左尖括号代表看左边，没有尖括号是看右边，感叹号是非的意思。")])]),t._v(" "),s("p",[t._v("环视中虽然也有括号，但不会保存成子组。保存成子组的一般是匹配到的文本内容，后续用于替换等操作，而环视是表示对文本左右环境的要求，即环视只匹配位置，不匹配文本内容。")]),t._v(" "),s("h2",{attrs:{id:"贪婪与非贪婪"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#贪婪与非贪婪"}},[t._v("#")]),t._v(" 贪婪与非贪婪")]),t._v(" "),s("h3",{attrs:{id:"贪婪匹配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#贪婪匹配"}},[t._v("#")]),t._v(" 贪婪匹配")]),t._v(" "),s("p",[t._v("在正则中，表示次数的量词默认是贪婪的，在贪婪模式下，会尝试尽可能最大长度去匹配。")]),t._v(" "),s("h3",{attrs:{id:"非贪婪匹配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非贪婪匹配"}},[t._v("#")]),t._v(" 非贪婪匹配")]),t._v(" "),s("p",[t._v("那么如何将贪婪模式变成非贪婪模式呢？我们可以在量词后面加上英文的问号 (?)，非贪婪模式会尽可能短地去匹配。")]),t._v(" "),s("h3",{attrs:{id:"举例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#举例"}},[t._v("#")]),t._v(" 举例")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[t._v("In "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" re                                                                                                                                       \n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 贪婪模式")]),t._v("\nIn "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" re"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("findall"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("r'\".+\"'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('\'"hello" seems "hi"\'')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("                                                                                                       \nOut"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('\'"hello" seems "hi"\'')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 非贪婪模式")]),t._v("\nIn "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" re"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("findall"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("r'\".+?\"'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('\'"hello" seems "hi"\'')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("                                                                                                      \nOut"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'\"hello\"'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'\"hi\"'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("h2",{attrs:{id:"独占模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#独占模式"}},[t._v("#")]),t._v(" 独占模式")]),t._v(" "),s("blockquote",[s("p",[t._v("python,go原生不支持独占模式，python可以通过regex包实现")])]),t._v(" "),s("h3",{attrs:{id:"回溯"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回溯"}},[t._v("#")]),t._v(" 回溯")]),t._v(" "),s("p",[t._v("对于下面的例子：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" regex\nregex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("findall"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("r'xy{1,3}yz'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'xyyz'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("首先"),s("code",[t._v("xy{1,3}")]),t._v("匹配到"),s("code",[t._v("xyy")]),t._v("字符，但发现"),s("code",[t._v("yz")]),t._v("无法匹配到剩余的"),s("code",[t._v("z")]),t._v("字符，此时会发生回溯，即"),s("code",[t._v("xy{1,3}")]),t._v("匹配到"),s("code",[t._v("xy")]),t._v("字符，由"),s("code",[t._v("yz")]),t._v("匹配剩下的"),s("code",[t._v("yz")]),t._v("字符")]),t._v(" "),s("p",[t._v("回溯会根据需要「返回部分已经匹配到的字符」以匹配接下来的字符。")]),t._v(" "),s("p",[t._v("当匹配的字符很长的时候，回溯会造成大量CPU占用，比如"),s("code",[t._v("xy{1,5}yyyyz")]),t._v("去匹配"),s("code",[t._v("xyyyyyz")]),t._v("时，要经历18个步骤，因为"),s("code",[t._v("xy{1,5}")]),t._v("由于贪婪匹配会匹配到"),s("code",[t._v("xyyyyy")]),t._v("然后发现"),s("code",[t._v("z")]),t._v("不能匹配，又会不断尝试"),s("code",[t._v("yz")]),t._v(","),s("code",[t._v("yyz")]),t._v(","),s("code",[t._v("yyyz")]),t._v("是否可以匹配。")]),t._v(" "),s("h3",{attrs:{id:"独占模式-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#独占模式-2"}},[t._v("#")]),t._v(" 独占模式")]),t._v(" "),s("p",[t._v("独占模式：在贪婪模式的基础上取消了回溯的机制，可以在量词的基础上添加"),s("code",[t._v("+")]),t._v("号实现。")]),t._v(" "),s("p",[t._v("对于"),s("code",[t._v("xy{1,5}+yyyyz")]),t._v("去匹配"),s("code",[t._v("xyyyyyz")]),t._v("时，首先"),s("code",[t._v("xy{1,5}+")]),t._v("贪婪匹配到"),s("code",[t._v("xyyyyy")]),t._v("，剩下的"),s("code",[t._v("z")]),t._v("无法匹配，于是匹配失败，不再进行回溯。")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" regex\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" regex\nregex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("findall"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("r'xy{1,5}+yyyyz'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'xyyyyyz'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# []")]),t._v("\n")])])]),s("h2",{attrs:{id:"分组与引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分组与引用"}},[t._v("#")]),t._v(" 分组与引用")]),t._v(" "),s("h3",{attrs:{id:"分组与编号"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分组与编号"}},[t._v("#")]),t._v(" 分组与编号")]),t._v(" "),s("p",[t._v("括号在正则中可以用于分组，被括号括起来的部分“子表达式”会被保存成一个子组。")]),t._v(" "),s("p",[t._v("那分组和编号的规则是怎样的呢？其实很简单，用一句话来说就是，第几个括号就是第几个分组。")]),t._v(" "),s("h3",{attrs:{id:"不保存子组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不保存子组"}},[t._v("#")]),t._v(" 不保存子组")]),t._v(" "),s("p",[t._v("在括号里面的会保存成子组，但有些情况下，你可能只想用括号将某些部分看成一个整体，后续不用再用它，类似这种情况，在实际使用时，是没必要保存子组的。这时我们可以在括号里面使用"),s("code",[t._v("?:")]),t._v(" 不保存子组，此时括号只用于归组，把某个部分当成“单个元素”，不分配编号，后面不会再进行这部分的引用。")]),t._v(" "),s("p",[t._v("比如"),s("code",[t._v("\\d{15}(?:\\d{3})")])]),t._v(" "),s("h3",{attrs:{id:"括号嵌套"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#括号嵌套"}},[t._v("#")]),t._v(" 括号嵌套")]),t._v(" "),s("p",[t._v("在括号嵌套的情况里，我们要看某个括号里面的内容是第几个分组怎么办？不要担心，其实方法很简单，我们只需要数左括号（开括号）是第几个，就可以确定是第几个子组。")]),t._v(" "),s("p",[t._v("比如"),s("code",[t._v("((\\d{4})-(\\d{2}))")]),t._v("中，分组1为"),s("code",[t._v("((\\d{4})-(\\d{2}))")]),t._v("，分组2为"),s("code",[t._v("(\\d{4})")]),t._v("，分组3为"),s("code",[t._v("(\\d{2})")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"命名分组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命名分组"}},[t._v("#")]),t._v(" 命名分组")]),t._v(" "),s("p",[t._v("由于编号得数在第几个位置，后续如果发现正则有问题，改动了括号的个数，还可能导致编号发生变化，因此一些编程语言提供了命名分组（named grouping），这样和数字相比更容易辨识，不容易出错。命名分组的格式为"),s("code",[t._v("(?P<分组名>正则)")]),t._v("。")]),t._v(" "),s("p",[t._v("比如django中，"),s("code",[t._v("url(r'^profile/(?P<username>\\w+)/$', view_func)")])]),t._v(" "),s("p",[t._v("命名分组和前面一样，也会分配一个编号，不过你可以使用名称，不用编号。")]),t._v(" "),s("h3",{attrs:{id:"分组引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分组引用"}},[t._v("#")]),t._v(" 分组引用")]),t._v(" "),s("p",[t._v("知道了分组引用的编号 （number）后，大部分情况下，我们就可以使用 “反斜扛 + 编号”，即 \\number 的方式来进行引用，而 JavaScript 中是通过"),s("code",[t._v("$编号")]),t._v("来引用，如$1。")]),t._v(" "),s("h4",{attrs:{id:"在查找中使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在查找中使用"}},[t._v("#")]),t._v(" 在查找中使用")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[t._v("re"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("search"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("r'(\\w+) \\1'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hello hello world'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# <re.Match object; span=(0, 11), match='hello hello'>")]),t._v("\n")])])]),s("h4",{attrs:{id:"在替换中使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在替换中使用"}},[t._v("#")]),t._v(" 在替换中使用")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[t._v("test_str "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"2020-05-10 20:23:05"')]),t._v("\nregex "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('r"((\\d{4})-(\\d{2})-(\\d{2})) ((\\d{2}):(\\d{2}):(\\d{2}))"')]),t._v("\nsubst "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('r"日期\\1 时间\\5 \\2年\\3月\\4日 \\6时\\7分\\8秒"')]),t._v("\nre"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sub"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" subst"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" test_str"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 日期2020-05-10 时间20:23:05 2020年05月10日 20时23分05秒")]),t._v("\n")])])]),s("h2",{attrs:{id:"匹配模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#匹配模式"}},[t._v("#")]),t._v(" 匹配模式")]),t._v(" "),s("p",[t._v("所谓匹配模式，指的是正则中一些改变元字符匹配行为的方式，比如匹配时不区分英文字母大小写。")]),t._v(" "),s("p",[t._v("常见的匹配模式有 4 种，分别是")]),t._v(" "),s("ul",[s("li",[t._v("不区分大小写模式")]),t._v(" "),s("li",[t._v("点号通配模式")]),t._v(" "),s("li",[t._v("多行模式")]),t._v(" "),s("li",[t._v("注释模式。")])]),t._v(" "),s("h3",{attrs:{id:"不区分大小写模式（case-insensitive）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不区分大小写模式（case-insensitive）"}},[t._v("#")]),t._v(" 不区分大小写模式（Case-Insensitive）")]),t._v(" "),s("p",[s("strong",[t._v("模式修饰符")]),t._v("是通过 (? 模式标识) 的方式来表示的。 我们只需要把模式修饰符放在对应的正则前，就可以使用指定的模式了。")]),t._v(" "),s("p",[t._v("在不区分大小写模式中，由于不分大小写的英文是 Case-Insensitive，那么对应的模式标识就是 I 的小写字母 i，所以不区分大小写的 cat 就可以写成"),s("code",[t._v("(?i)cat")]),t._v("。 "),s("a",{attrs:{href:"https://regex101.com/r/x1lg4P/1",target:"_blank",rel:"noopener noreferrer"}},[t._v("测试案例"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("如果我们想要前面匹配上的结果，和第二次重复时的大小写一致，那该怎么做呢？我们只需要用括号把修饰符和正则 cat 部分括起来，加括号相当于作用范围的限定，让不区分大小写只作用于这个括号里的内容。"),s("a",{attrs:{href:"https://regex101.com/r/x1lg4P/2",target:"_blank",rel:"noopener noreferrer"}},[t._v("测试案例"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("如果用正则匹配，实现部分区分大小写，另一部分不区分大小写，这该如何操作呢？就比如说我现在想要，the cat 中的 the 不区分大小写，cat 区分大小写，可以写成"),s("code",[t._v("((?i)the) cat")]),t._v(" 。"),s("a",{attrs:{href:"https://regex101.com/r/x1lg4P/3",target:"_blank",rel:"noopener noreferrer"}},[t._v("测试案例"),s("OutboundLink")],1)]),t._v(" "),s("blockquote",[s("p",[t._v("JS中使用/regex/i 来指定匹配模式")]),t._v(" "),s("p",[t._v('Python中使用re.findall(r"cat", "CAT Cat cat", re.IGNORECASE)来指定')])]),t._v(" "),s("h3",{attrs:{id:"点号通配模式（dot-all）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#点号通配模式（dot-all）"}},[t._v("#")]),t._v(" 点号通配模式（Dot All）")]),t._v(" "),s("p",[t._v("你还记得英文的点（.）有什么用吗？它可以匹配上任何符号，但不能匹配换行。当我们需要匹配真正的“任意”符号的时候，可以使用 [\\s\\S] 或 [\\d\\D] 或 [\\w\\W] 等。")]),t._v(" "),s("p",[t._v("但是这么写不够简洁自然，所以正则中提供了一种模式，让英文的点（.）可以匹配上包括换行的任何字符。")]),t._v(" "),s("p",[t._v("这个模式就是点号通配模式，有很多地方把它称作单行匹配模式，但这么说容易造成误解，毕竟它与多行匹配模式没有联系。")]),t._v(" "),s("p",[t._v("单行的英文表示是 Single Line，单行模式对应的修饰符是"),s("code",[t._v("(?s)")]),t._v("，比如"),s("code",[t._v("(?s).+")])]),t._v(" "),s("blockquote",[s("p",[t._v("JS不支持此模式")])]),t._v(" "),s("h3",{attrs:{id:"多行匹配模式（multiline）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多行匹配模式（multiline）"}},[t._v("#")]),t._v(" 多行匹配模式（Multiline）")]),t._v(" "),s("p",[t._v("通常情况下，^匹配整个字符串的开头，$ 匹配整个字符串的结尾。多行匹配模式改变的就是 ^ 和 $ 的匹配行为。")]),t._v(" "),s("p",[t._v("多行模式的作用在于，使  ^ 和 $ 能匹配上每行的开头或结尾，我们可以使用模式修饰符号"),s("code",[t._v("(?m)")]),t._v("来指定这个模式。")]),t._v(" "),s("p",[t._v("比如"),s("code",[t._v("(?m)^the|cat$")])]),t._v(" "),s("p",[t._v("这个模式有什么用呢？在处理日志时，如果日志以时间开头，有一些日志打印了堆栈信息，占用了多行，我们就可以使用多行匹配模式，在日志中匹配到以时间开头的每一行日志。")]),t._v(" "),s("p",[t._v("值得一提的是，正则中还有 \\A 和 \\z（Python 中是 \\Z） 这两个元字符容易混淆，\\A 仅匹配整个字符串的开始，\\z 仅匹配整个字符串的结束，在多行匹配模式下，它们的匹配行为不会改变，如果只想匹配整个字符串，而不是匹配每一行，用这个更严谨一些。")]),t._v(" "),s("h3",{attrs:{id:"注释模式（comment）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注释模式（comment）"}},[t._v("#")]),t._v(" 注释模式（Comment）")]),t._v(" "),s("p",[t._v("我们在写代码的时候，通常会在一些关键的地方加上注释，让代码更易于理解。很多语言也支持在正则中添加注释，让正则更容易阅读和维护，这就是正则的注释模式。正则中注释模式是使用"),s("code",[t._v("(?#comment)")]),t._v("来表示。")]),t._v(" "),s("p",[t._v("比如"),s("code",[t._v("(\\w+)(?#word) \\1(?#word repeat again)")])]),t._v(" "),s("h3",{attrs:{id:"x模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#x模式"}},[t._v("#")]),t._v(" x模式")]),t._v(" "),s("p",[t._v("在 x 模式下，所有的换行和空格都会被忽略。")]),t._v(" "),s("p",[t._v("为了换行和空格的正确使用，我们可以通过把空格放入字符组中，或将空格转义来解决换行和空格的忽略问题。")]),t._v(" "),s("p",[t._v("很多编程语言中也提供了 x 模式来书写正则，也可以起到注释的作用。")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[t._v("regex "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token triple-quoted-string string"}},[t._v("r'''(?mx)\n^          # 开头\n(\\d{4})    # 年\n[ ]        # 空格\n(\\d{2})    # 月\n$          # 结尾\n'''")]),t._v("\n\nre"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("findall"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2020 06\\n2020 07'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 输出结果 [('2020', '06'), ('2020', '07')]")]),t._v("\n")])])])])}),[],!1,null,null,null);a.default=v.exports}}]);